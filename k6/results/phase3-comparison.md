# Phase 3 Step 1 / 2 / 3 전체 비교

**측정 일시:** 2026-02-21
**실행 방법:** java -jar (직접 JAR 실행)
**k6 시나리오:** queue-enrollment-rush.js (Burst + Sustained 패턴)
**측정 횟수:** 각 조건 2~3회 측정 후 평균

---

## Step별 아키텍처 차이

| 항목 | Step 1 | Step 2 | Step 3 |
|------|--------|--------|--------|
| **큐 처리** | 순차 (1 스레드) | 병렬 (20 스레드) | 병렬 (20 스레드) |
| **Lua Script** | 미사용 | 미사용 | 사용 (enqueue, getResult, isFull) |
| **enqueue Redis 호출** | 6+ 회 (개별 명령) | 6+ 회 (개별 명령) | 1회 (원자 스크립트) |
| **getResult Redis 호출** | 3~4회 | 3~4회 | 1회 (원자 스크립트) |
| **isFull Redis 호출** | 2회 (GET × 2) | 2회 (GET × 2) | 1회 (Lua Script) |
| **최적화 초점** | 기본 큐 구현 | 처리량 (병렬화) | 지연시간 (원자 연산) |

---

## 1. VU 확장성 비교 (톰캣 1000 스레드 고정)

### 1000 VU

| 지표 | Step 1 | Step 2 | Step 3 |
|------|:---:|:---:|:---:|
| **에러율** | 0% | 0% | 0% |
| **수강 성공** | ~3,952 | 3,957 | 3,957 |
| **Submit p95** | 3.5ms | 4.8ms | **1.5ms** |
| **Submit p95 (Burst)** | 4.3ms | 6.7ms | **2.3ms** |
| **Submit p95 (Sustained)** | 2.5ms | 3.8ms | **1.2ms** |
| **Wait p95** | 10.2s | **2.5s** | **2.5s** |
| **iterations/s** | 115 | **349.8** | **353.7** |

### 2000 VU

| 지표 | Step 1 | Step 2 | Step 3 |
|------|:---:|:---:|:---:|
| **에러율** | 0% | 0% | 0% |
| **수강 성공** | ~3,957 | 3,957 | 3,957 |
| **Submit p95** | 7.7ms | 8.5ms | **2.8ms** |
| **Submit p95 (Burst)** | 11ms | 23ms | **6.0ms** |
| **Submit p95 (Sustained)** | 2.6ms | 5.3ms | **1.5ms** |
| **Wait p95** | 21s | **5.5s** | **5.5s** |
| **iterations/s** | 120 | **349.1** | **352.0** |

### 3000 VU

| 지표 | Step 1 | Step 2 | Step 3 |
|------|:---:|:---:|:---:|
| **에러율** | 0% | 0% | 0% |
| **수강 성공** | ~3,957 | 3,957 | 3,957 |
| **Submit p95** | 62ms | 101.8ms | **9.8ms** |
| **Submit p95 (Burst)** | 72.8ms | 173.3ms | **23.3ms** |
| **Submit p95 (Sustained)** | 2.8ms | 5.3ms | **1.5ms** |
| **Wait p95** | 31.5s | **8.5s** | **8.5s** |
| **iterations/s** | 122 | **348.9** | **352.3** |

---

## 2. 톰캣 스레드풀 비교 (3000 VU 고정)

| 지표 | Step 1 500t | Step 1 1000t | Step 1 2000t | Step 2 500t | Step 2 1000t | Step 2 2000t | Step 3 500t | Step 3 1000t | Step 3 2000t |
|------|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **Submit p95** | 173ms | 62ms | 60.5ms | **23.5ms** | 101.8ms | 100.8ms | 7.8ms | 9.8ms | **7.5ms** |
| **Wait p95** | 31.2s | 31.5s | **54.1s** | 8.5s | 8.5s | 8.5s | 8.5s | 8.5s | 8.5s |
| **iterations/s** | 123.2 | 122.1 | **67.6** | 350.8 | 348.9 | 349.4 | 353.2 | 352.3 | 352.8 |

### 스레드풀 민감도 변화

| 특성 | Step 1 | Step 2 | Step 3 |
|------|--------|--------|--------|
| **처리량 영향** | 2000t에서 45% 하락 | 영향 없음 | 영향 없음 |
| **Submit 영향** | 500t 가장 느림 | 500t 가장 빠름 | 차이 없음 |
| **최적 스레드** | 1000t | 500t | **어떤 값이든 동일** |

Step이 올라갈수록 톰캣 스레드풀에 대한 민감도가 사라진다.

---

## 3. Step별 개선 분석

### Step 1 → Step 2: 병렬 처리 (20 스레드)

| 지표 | 개선 | 원인 |
|------|------|------|
| **iterations/s** | 122 → **349** (+186%) | 20 스레드 병렬 처리로 큐 워커 처리량 3배 |
| **Wait p95 (3000VU)** | 31.5s → **8.5s** (-73%) | 큐가 빠르게 소화되어 대기 시간 단축 |
| **Submit p95 (3000VU)** | 62ms → 101.8ms (+64%) | iteration이 빨라져 VU가 더 자주 요청 |
| **스레드풀 민감도** | 2000t에서 45% 하락 | 해소됨 |

### Step 2 → Step 3: Lua Script 원자 연산

| 지표 | 개선 | 원인 |
|------|------|------|
| **Submit p95 (3000VU)** | 101.8ms → **9.8ms** (-90%) | enqueue 6회 → 1회 원자 실행 |
| **Submit median** | 2ms → **0.5ms** (-75%) | Redis 왕복 횟수 감소 |
| **iterations/s** | 349 → **352** (+1%) | 미미한 차이 |
| **Wait p95** | 8.5s → 8.5s (동일) | 큐 워커 처리 속도 변화 없음 |
| **스레드풀 민감도** | 500t 유리 | 완전 해소 |

---

## 4. 종합 결론

### 처리량 한계 (iterations/s)

```
Step 1:  ~122 iter/s  ──────  순차 처리 (1 스레드)
                        ×2.9
Step 2:  ~349 iter/s  ──────  병렬 처리 (20 스레드)
                        ×1.0
Step 3:  ~352 iter/s  ──────  Lua Script (Submit 최적화, 워커 동일)
```

Step 2의 병렬화가 처리량을 3배로 끌어올렸고, Step 3의 Lua Script는 처리량이 아닌 **Submit 지연시간**을 개선했다.

### Submit 응답 시간 (3000 VU p95)

```
Step 1:   62ms    ──────  개별 Redis 명령, 순차 처리
                    ×1.6 악화 (iteration 빨라져 요청 빈도 증가)
Step 2:  101.8ms  ──────  개별 Redis 명령, 병렬 처리
                    ×0.1 (90% 개선)
Step 3:    9.8ms  ──────  Lua Script 원자 연산
```

### Wait 대기 시간 (3000 VU p95)

```
Step 1:  31.5s  ──────  큐 워커 느려서 대기열 체류 시간 김
                  ×0.27 (73% 개선)
Step 2:   8.5s  ──────  병렬 처리로 빠르게 소화
                  ×1.0
Step 3:   8.5s  ──────  워커 동일, 대기 시간 동일
```

### 최적 구성

| 항목 | Step 1 | Step 2 | Step 3 |
|------|--------|--------|--------|
| **권장 스레드** | 1000t | 500t | 500t |
| **처리 한계** | ~122 iter/s | ~349 iter/s | ~352 iter/s |
| **3000VU Submit p95** | 62ms | 101.8ms | **9.8ms** |
| **3000VU Wait p95** | 31.5s | 8.5s | 8.5s |

### 핵심 발견

1. **병렬화(Step 2)가 처리량의 결정적 개선**: 순차 → 20 스레드로 iterations/s 3배 증가
2. **Lua Script(Step 3)는 지연시간의 결정적 개선**: Submit p95 90% 감소, 하지만 처리량은 동일
3. **모든 Step에서 에러율 0%, 정원 초과 0건**: 큐 아키텍처의 안정성 완벽
4. **Step이 올라갈수록 톰캣 스레드풀 민감도 소멸**: Step 3에서는 500t~2000t 성능 동일
5. **병목 이동**: Step 1(톰캣 스레드 + 큐 워커) → Step 2(큐 워커) → Step 3(큐 워커만, Submit 병목 해소)
