# Phase 3 Step 2 부하테스트 결과

**측정 일시:** 2026-02-21
**실행 방법:** java -jar (직접 JAR 실행)
**k6 시나리오:** queue-enrollment-rush.js (Burst + Sustained 패턴)
**테스트 대상:** phase3-step2 (Redis Queue 기반 수강신청)
**측정 횟수:** 각 조건 2~3회 측정 후 평균

---

## 1. VU 확장성 테스트 (톰캣 1000 스레드 고정)

| 지표 | 1000 VU | 2000 VU | 3000 VU |
|------|:---:|:---:|:---:|
| **에러율** | 0% | 0% | 0% |
| **수강 성공** | 3,957 | 3,957 | 3,957 |
| **Submit p95** | 4.8ms | 8.5ms | 101.8ms |
| **Submit p95 (Burst)** | 6.7ms | 23ms | 173.3ms |
| **Submit p95 (Sustained)** | 3.8ms | 5.3ms | 5.3ms |
| **Wait p95** | 2.5s | 5.5s | 8.5s |
| **iterations/s** | 349.8 | 349.1 | 348.9 |
| **req/s** | 995 | 1,451 | 1,823 |

### 분석

- **에러율 0%**: 3000 VU에서도 서버 에러 없이 전량 처리.
- **수강 성공 3,957건 일정**: 정원 제한이 정확히 동작. 동시성 제어 완벽.
- **Submit p95**: 1000→2000 VU는 선형 증가(4.8→8.5ms), 3000 VU에서 급증(101.8ms). iterations/s가 높아 VU가 더 자주 POST를 보내기 때문.
- **Wait p95**: VU에 비례 증가하지만 Step 1 대비 대폭 단축 (10s→2.5s, 31.5s→8.5s).
- **iterations/s ~349로 수렴**: VU와 무관하게 일정. **초당 ~349건이 시스템 처리 한계**.

---

## 2. 톰캣 스레드풀 비교 (3000 VU 고정)

| 지표 | 500t | 1000t | 2000t |
|------|:---:|:---:|:---:|
| **에러율** | 0% | 0% | 0% |
| **수강 성공** | 3,954 | 3,957 | 3,955 |
| **Submit p95** | **23.5ms** | 101.8ms | 100.8ms |
| **Submit p95 (Burst)** | **35.4ms** | 173.3ms | 174.2ms |
| **Submit p95 (Sustained)** | 5.5ms | 5.3ms | 5.2ms |
| **Wait p95** | 8.5s | 8.5s | 8.5s |
| **iterations/s** | 350.8 | 348.9 | 349.4 |
| **req/s** | 1,827 | 1,823 | 1,827 |

### 분석

#### Step 1과 완전히 다른 양상

Step 1에서는 스레드 수에 따라 Wait와 iterations/s가 크게 달랐다 (2000t는 처리량 45% 하락). Step 2에서는 Wait p95(8.5s)와 iterations/s(~350)가 **스레드 수와 무관하게 완전히 동일**하다. 큐 워커가 충분히 빨라져서 톰캣 스레드의 폴링 경합이 해소되었기 때문이다.

#### 500t가 Submit이 가장 빠른 이유

Step 1에서는 500t가 Submit이 가장 느렸지만, Step 2에서는 **가장 빠르다** (23.5ms vs 1000t의 101.8ms).

Step 2는 iterations/s가 3배 높아서 VU가 훨씬 자주 POST를 보낸다. 1000t/2000t에서는 많은 스레드가 동시에 Redis ZADD를 호출하며 순간 경합이 심해진다. 반면 500t는 Accept Queue가 자연스러운 **속도 조절기** 역할을 하여 Redis 경합을 줄인다.

---

## 3. Step 1 vs Step 2 비교 (1000t 기준)

| 지표 | Step 1 (1000VU) | Step 2 (1000VU) | Step 1 (2000VU) | Step 2 (2000VU) | Step 1 (3000VU) | Step 2 (3000VU) |
|------|:---:|:---:|:---:|:---:|:---:|:---:|
| **에러율** | 0% | 0% | 0% | 0% | 0% | 0% |
| **수강 성공** | ~3,952 | 3,957 | ~3,957 | 3,957 | ~3,957 | 3,957 |
| **Submit p95** | 3.5ms | 4.8ms | 7.7ms | 8.5ms | 62ms | 101.8ms |
| **Submit p95 (Burst)** | 4.3ms | 6.7ms | 11ms | 23ms | 72.8ms | 173.3ms |
| **Submit p95 (Sustained)** | 2.5ms | 3.8ms | 2.6ms | 5.3ms | 2.8ms | 5.3ms |
| **Wait p95** | **10.2s** | **2.5s** | **21s** | **5.5s** | **31.5s** | **8.5s** |
| **iterations/s** | **115** | **349.8** | **120** | **349.1** | **122** | **348.9** |
| **req/s** | 976 | 995 | 1,443 | 1,451 | 1,828 | 1,823 |

### 핵심 개선

- **Wait p95**: Step 2가 전 구간 **3.7~4배 빠름**
- **iterations/s**: Step 2가 **2.9배 높음** (122 → 349), VU와 무관하게 일정
- **Submit p95**: Step 2가 오히려 높지만, iteration이 빨리 끝나 VU가 더 자주 요청하기 때문

---

## 4. 종합 결론

### 최적 구성

| 항목 | 권장 값 | 근거 |
|------|---------|------|
| 톰캣 스레드 | **500** | Submit 가장 빠르고, 처리량 동일 |
| 운영 가능 VU | **~2000** | Submit p95 8.5ms, Wait 5.5s |
| 시스템 처리 한계 | **~349 iter/s** | VU·스레드 수와 무관하게 수렴 |

### 핵심 발견

1. **큐 워커 처리 속도 3배 향상**: Step 1의 ~122 iter/s → Step 2의 ~349 iter/s
2. **Wait 시간 4배 단축**: 3000 VU 기준 31.5s → 8.5s
3. **스레드풀이 처리량에 무영향**: 병목이 톰캣에서 큐 워커로 완전 이동
4. **500t에서 Submit이 가장 빠른 역전 현상**: Accept Queue가 Burst를 분산시켜 Redis 경합 감소
5. **에러율 0%, 정원 제어 완벽**: 모든 조건에서 유지
