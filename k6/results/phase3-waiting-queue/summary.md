# Phase 3: Redis Sorted Set 수강신청 대기열 시스템 성능 측정 결과 (Instant Spike, java -jar)

**측정 일시:** 2026-02-20
**실행 방법:** `java -jar phase3-queue.jar --spring.profiles.active=mysql,redis`
**누적 최적화:** HikariCP pool=30 + OSIV OFF + Redis 원자 연산/캐싱 + 대기열 + 20스레드 병렬 처리 + Lua Script enqueue + INCR 근사 순번 + Tomcat 5000스레드
**프로파일:** mysql,redis
**테스트 시나리오:** queue-enrollment-rush (1초 instant spike, 1m 지속, 5s 쿨다운)

---

## 대기열 동작 방식

```
학생(클라이언트)                         서버
  │                                      │
  ├─ POST /api/queue/enroll ──────────►  │ Lua Script: INCR+HSET+ZADD 원자 실행
  │  {studentId, courseId}               │ → token + 근사 대기순번 반환
  │                                      │
  │                                      │ @Scheduled(fixedDelay=100ms)
  │                                      │ ZPOPMIN 50건 → 20스레드 병렬 처리
  │                                      │ EnrollmentService.enroll() 자동 호출
  │                                      │ → 결과를 Redis Hash에 저장
  │                                      │
  ├─ GET /api/queue/result/{token} ──►   │ 결과 조회 (ZSCORE O(1) + 근사 순번)
  │  (순번 기반 폴링 간격)               │ → WAITING / SUCCESS / FAILED
  │                                      │
  │  결과 확인 후 1초 대기               │
  │                                      │
  ├─ POST /api/queue/enroll ──────────►  │ 다음 강좌 수강신청
  │  {studentId, 다른 courseId}          │
  └──────────────────────────────────    └─
```

### 순번 기반 폴링 간격 (서버 부하 제어)
| 대기 순번 | 폴링 간격 | 이유 |
|-----------|-----------|------|
| 1~100 | 0.5초 | 곧 처리될 순번 |
| 101~500 | 1.5초 | 중간 순번 |
| 501~1500 | 3초 | 뒤쪽 순번 |
| 1500+ | 5초 | 한참 뒤 순번 |

---

## Queue Enrollment Rush 결과 (3,000 VU, 3회 측정 평균)

| 지표 | 1차 | 2차 | 3차 | 평균 |
|------|-----|-----|-----|------|
| iterations/s | 401 | 403 | 403 | **402** |
| http_reqs/s | 1,120 | 1,084 | 1,109 | **1,104** |
| http_req_duration p95 | 52.9ms | 7.0ms | 5.0ms | **21.6ms** |
| http_req_duration avg | 20.7ms | 20.9ms | 27.0ms | **22.9ms** |
| http_req_duration med | 1.22ms | 1.0ms | 1.0ms | **1.07ms** |
| queue_submit p95 | 437ms | 535ms | 670ms | **547ms** |
| queue_submit avg | 50.6ms | 53.7ms | 71.8ms | **58.7ms** |
| queue_wait avg | 5,939ms | 5,913ms | 5,906ms | **5,919ms** |
| queue_wait p95 | 8,004ms | 8,004ms | 8,003ms | **8,004ms** |
| **enroll_success** | **2,018** | **2,018** | **2,018** | **2,018** |
| enroll_failed | 26,582 | 26,512 | 26,621 | 26,572 |
| http_req_failed | 0.00% | 0.04% | 0.00% | **~0.01%** |
| checks_failed | 0.00% | 0.11% | 0.01% | **~0.04%** |
| iteration_duration avg | 7.0s | 7.0s | 7.0s | **7.0s** |
| iteration_duration p95 | 9.0s | 9.0s | 9.0s | **9.0s** |
| 총 iterations | 28,600 | 28,564 | 28,644 | **28,603** |
| max VUs | 3,000 | 3,000 | 3,000 | **3,000** |

---

## Phase 0~3 전체 비교표

| 지표 | Phase 0 | Phase 1 (Step 2) | Phase 2 (Redis) | Phase 3 (3,000 VU) |
|------|---------|-------------------|-----------------|-------------------|
| http_req_duration p95 | 128ms | 43.5ms | 10.5ms | **21.6ms** ※ |
| http_req_duration avg | 70.0ms | 24.2ms | 6.2ms | **22.9ms** ※ |
| enroll_success | 2,018 | 2,018 | 2,018 | **2,018** |
| 총 수강신청 시도 | 192,698 | 263,242 | 307,215 | **28,603** |
| 불필요한 실패 요청 | 190,680 | 261,224 | 305,197 | **26,572** |
| 5xx 에러 | 0 | 0 | 0 | **0** |
| max VUs | 500 | 500 | 500 | **3,000** |

> ※ Phase 3 p95/avg가 높은 이유: 초반 3,000명 instant spike 시 Lua Script enqueue가 직렬 실행되면서 일부 submit 응답이 길어짐. med(중앙값)는 1.07ms로 대부분의 요청은 1ms 이내. 1차 측정 p95(52.9ms)가 2·3차(7ms, 5ms)보다 높아 편차가 큼.
>
> **비교 시 유의사항:**
> - Phase 0~2: enrollment-rush (500 VU, 직접 수강신청). 즉시 응답 → 즉시 재시도.
> - Phase 3: queue-enrollment-rush (3,000 VU, 대기열). 1 VU = 1 학생. 신청 → 서버 자동 처리 → 결과 폴링 → 다음 강좌.
> - 모든 Phase는 `java -jar`로 실행하여 측정.

---

## 핵심 변화: 대기열 도입의 패러다임 전환

### 1. 사용자 경험의 변화
| 항목 | Phase 0~2 (직접 수강신청) | Phase 3 (대기열) |
|------|--------------------------|-----------------|
| 수강신청 방식 | 버튼 클릭 → 즉시 성공/실패 | 버튼 클릭 → 대기 → 자동 처리 → 결과 통보 |
| 정원 찬 강좌 | 즉시 "정원 초과" 에러 | 대기열에서 처리 후 "정원 초과" 결과 |
| 재시도 패턴 | 미친듯이 버튼 연타 | 결과 받고 다른 강좌 신청 |
| 동시 접속 한계 | 500 VU | **3,000 VU** (6배) |

### 2. 서버 부하의 극적 감소
- **총 수강신청 시도**: 192,698건 → **28,603건** (**-85.2%**)
- **불필요한 실패 요청**: 190,680건 → **26,572건** (**-86.1%**)
- 순번 기반 폴링 간격이 뒤쪽 학생의 불필요한 요청을 억제

### 3. HTTP 에러율
- **Phase 0~2**: 대부분의 요청이 409 정원 초과
- **Phase 3**: http_req_failed **~0.01%**
- 수강신청 결과가 HTTP 에러가 아닌 결과 데이터(SUCCESS/FAILED)로 전달

### 4. 사용자 체감 대기 시간
- **queue_wait avg**: 5,919ms (신청 후 결과까지 평균 ~6초)
- **queue_wait p95**: 8,004ms (최대 ~8초)
- 3,000명이 1초만에 몰리는 극한 상황에서 대부분 9초 이내 결과 확인

### 5. 데이터 정합성
- **enroll_success**: 3회 모두 정확히 **2,018건**
- 인기 강좌(1~50번) 정원 합계와 100% 일치
- 20스레드 병렬 처리에서도 동시성 제어 정확히 동작

---

## Phase 3 내부 최적화 이력

| 개선 | 효과 (3,000 VU 기준) |
|------|---------------------|
| **병렬 처리** (20스레드) | queue_wait -57%, 처리량 2배 (181→402 iter/s) |
| **Tomcat 튜닝** (5000스레드) | submit p95 -95% (Redis-only 엔드포인트) |
| **Lua Script** (enqueue 1회 왕복) | 네트워크 왕복 6→1, 원자적 실행 |
| **INCR 근사 순번** (ZRANK/ZCARD 제거) | submit p95 -34%, submit avg -31% |

---

## Phase 0→3 전체 개선 요약

| 개선 항목 | Phase 0 → Phase 3 | 개선율 |
|-----------|-------------------|--------|
| HTTP 응답시간 p95 | 128ms → 21.6ms | **-83.1%** |
| 총 수강신청 시도 | 192,698건 → 28,603건 | **-85.2%** |
| 불필요한 실패 요청 | 190,680건 → 26,572건 | **-86.1%** |
| 동시 접속 한계 | 500 VU → 3,000 VU | **6배 증가** |
| 서버 에러 | 0건 → 0건 | 안정적 유지 |
| 수강 성공 | 2,018건 → 2,018건 | 정합성 유지 |

### 각 Phase별 핵심 기여
1. **Phase 1** (HikariCP pool=30 + OSIV OFF): 커넥션 관리 최적화 → p95 -66.0%
2. **Phase 2** (Redis 원자 연산): DB 락 제거 → p95 -75.9% (Phase 0 대비 -91.8%)
3. **Phase 3** (대기열 + 병렬 + Lua + INCR): 패러다임 전환 → HTTP 에러율 ~0%, 동시 접속 6배, 불필요한 트래픽 86.1% 감소
