# Phase 3: Redis Sorted Set 수강신청 대기열 시스템 성능 측정 결과

**측정 일시:** 2026-02-19
**변경 사항:** Redis Sorted Set 기반 수강신청 대기열 시스템 (서버 자동 처리, BATCH_SIZE=50, 순번 기반 폴링)
**누적 최적화:** HikariCP pool=30 + OSIV OFF + Hibernate batch + 인덱스 + Redis 원자 연산/캐싱 + 대기열 + Tomcat 1000스레드
**프로파일:** mysql,redis
**테스트 시나리오:** queue-enrollment-rush (1 VU = 1 학생, 2초만에 1000명 동시 접속, 순차 수강신청)

---

## 대기열 동작 방식

```
학생(클라이언트)                         서버
  │                                      │
  ├─ POST /api/queue/enroll ──────────►  │ Redis Sorted Set에 요청 적재
  │  {studentId, courseId}               │ → token + 대기순번 반환
  │                                      │
  │                                      │ @Scheduled(fixedDelay=100ms)
  │                                      │ ZPOPMIN으로 50건씩 꺼내서
  │                                      │ EnrollmentService.enroll() 자동 호출
  │                                      │ → 결과를 Redis Hash에 저장
  │                                      │
  ├─ GET /api/queue/result/{token} ──►   │ 결과 조회
  │  (순번 기반 폴링 간격)               │ → WAITING / SUCCESS / FAILED
  │                                      │
  │  결과 확인 후 1초 대기               │
  │                                      │
  ├─ POST /api/queue/enroll ──────────►  │ 다음 강좌 수강신청
  │  {studentId, 다른 courseId}          │
  └──────────────────────────────────    └─
```

### 순번 기반 폴링 간격 (서버 부하 제어)
| 대기 순번 | 폴링 간격 | 이유 |
|-----------|-----------|------|
| 1~100 | 0.5초 | 곧 처리될 순번 |
| 101~500 | 1.5초 | 중간 순번 |
| 501~1500 | 3초 | 뒤쪽 순번 |
| 1500+ | 5초 | 한참 뒤 순번 |

---

## Queue Enrollment Rush 결과 (2초만에 1000명 동시 접속, 2m12s)

| 지표 | 값 |
|------|-----|
| iterations/s | 183.5 |
| http_reqs/s | 564.0 |
| http_req_duration avg | 15.85ms |
| http_req_duration p90 | 3.7ms |
| http_req_duration p95 | **5.15ms** |
| queue_submit_duration avg | 45.42ms |
| queue_submit_duration p95 | 9.97ms |
| queue_wait_duration avg | 4,184ms |
| queue_wait_duration p95 | 9,003ms |
| **enroll_success** | **2,018건** (DB 확인 일치) |
| **enroll_failed** | **22,451건** |
| enroll_success + enroll_failed | **24,469건** (= 총 iterations, 정확히 일치) |
| http_req_failed rate | **0.00%** |
| checks passed | 100% (24,469/24,469) |
| iteration_duration avg | 5.23s |
| iteration_duration p95 | 10.35s |
| 총 iterations | 24,469 |
| 총 http_reqs | 75,202 |
| interrupted iterations | **0건** (전원 정상 완료) |
| max VUs | **1,000** |

---

## Phase 0~3 전체 비교표

| 지표 | Phase 0 (baseline) | Phase 1 (최적화) | Phase 2 (Redis) | Phase 3 (대기열) |
|------|-------------------|-----------------|----------------|-----------------|
| http_req_duration p95 | 259.01ms | 204.99ms | 9.66ms | **5.15ms** |
| http_req_duration avg | 79.32ms | 57.44ms | 4.31ms | **15.85ms** ※ |
| enroll_success (DB 확인) | 2,018 | 2,018 | 2,018 | **2,018** |
| 총 수강신청 시도 | 298,796 | 340,827 | 515,214 | **24,469** |
| 불필요한 실패 요청 | 296,778 | 338,809 | 513,196 | **22,451** |
| http_req_failed rate | 99.32% | 99.40% | 99.60% | **0.00%** |
| 5xx 에러 | 0 | 0 | 0 | **0** |
| checks passed | 100% | 100% | 100% | **100%** |
| max VUs | 500 | 500 | 500 | **1,000** |

> ※ Phase 3 avg가 높은 이유: 초반 1000명 동시 접속 시 대기열 적재 요청이 몰리면서 일부 요청의 응답시간이 길어짐 (p95는 5.15ms로 양호). 중앙값(med)은 1.52ms.

> **비교 시 유의사항:**
> - Phase 0~2: 직접 수강신청 (500 VU). 즉시 응답 → 즉시 재시도.
> - Phase 3: 대기열 방식 (1000 VU). 1 VU = 1 학생 고정. 신청 → 서버 자동 처리 → 결과 폴링 → 다음 강좌.

---

## 핵심 변화: 대기열 도입의 패러다임 전환

### 1. 사용자 경험의 변화
| 항목 | Phase 0~2 (직접 수강신청) | Phase 3 (대기열) |
|------|--------------------------|-----------------|
| 수강신청 방식 | 버튼 클릭 → 즉시 성공/실패 | 버튼 클릭 → 대기 → 자동 처리 → 결과 통보 |
| 정원 찬 강좌 | 즉시 "정원 초과" 에러 | 대기열에서 처리 후 "정원 초과" 결과 |
| 재시도 패턴 | 미친듯이 버튼 연타 | 결과 받고 다른 강좌 신청 |
| 학생당 평균 시도 | 수백~수천 회 (같은 강좌 반복) | **~3.2회** (서로 다른 강좌 순차) |
| 동시 접속 한계 | 500 VU | **1,000 VU** (2배) |

### 2. 서버 부하의 극적 감소
- **총 수강신청 시도**: 298,796건 → **24,469건** (**-91.8%**)
- **불필요한 실패 요청**: 296,778건 → **22,451건** (**-92.4%**)
- 순번 기반 폴링 간격이 뒤쪽 학생의 불필요한 요청을 억제

### 3. HTTP 에러율
- **Phase 0~2**: http_req_failed 99.3~99.6% (대부분 409 정원 초과)
- **Phase 3**: http_req_failed **0.00%**
- 수강신청 결과가 HTTP 에러가 아닌 결과 데이터(SUCCESS/FAILED)로 전달

### 4. 사용자 체감 대기 시간
- **queue_wait_duration avg**: 4,184ms (신청 후 결과까지 평균 ~4초)
- **queue_wait_duration p95**: 9,003ms (최대 ~9초)
- 1000명이 2초만에 몰리는 극한 상황에서도 대부분 10초 이내 결과 확인

### 5. 데이터 정합성
- **enroll_success**: 2,018건 (모든 Phase에서 동일, DB 직접 조회 확인)
- 인기 강좌(1~50번) 정원 합계와 정확히 일치
- 대기열 순차 처리에서도 동시성 제어 정확히 동작

---

## Phase 0→3 전체 개선 요약

| 개선 항목 | Phase 0 → Phase 3 | 개선율 |
|-----------|-------------------|--------|
| HTTP 응답시간 p95 | 259.01ms → 5.15ms | **-98.0%** |
| HTTP 에러율 | 99.32% → 0.00% | **에러 제거** |
| 총 수강신청 시도 | 298,796건 → 24,469건 | **-91.8%** |
| 불필요한 실패 요청 | 296,778건 → 22,451건 | **-92.4%** |
| 동시 접속 한계 | 500 VU → 1,000 VU | **2배 증가** |
| 서버 에러 | 0건 → 0건 | 안정적 유지 |
| 수강 성공 | 2,018건 → 2,018건 | 정합성 유지 |

### 각 Phase별 핵심 기여
1. **Phase 1** (HikariCP + OSIV OFF): 커넥션 관리 최적화 → p95 -20.8%
2. **Phase 2** (Redis 원자 연산): DB 락 제거 → p95 -95.3%, 처리량 +50.6%
3. **Phase 3** (대기열): 서버 자동 처리 + 순번 기반 폴링 → p95 -46.7%, HTTP 에러율 0%, 동시 접속 2배, 불필요한 트래픽 92.4% 감소
