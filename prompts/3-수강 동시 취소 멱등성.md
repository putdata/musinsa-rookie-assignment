### Opus 4.6

/superpowers:brainstorm

Codex 5.3이 다음과 같은 진단을 내렸어.

[Critical] 동시 취소(같은 enrollmentId) 시 500 가능성이 큽니다.
     src/main/java/com/musinsa/service/enrollment/EnrollmentService.java:95에서 락 없이 Enrollment를 먼저 읽고, src/main/java/com/
     musinsa/service/enrollment/EnrollmentService.java:99에서 Course만 락을 잡습니다. 이 구조면 동일 DELETE 동시 요청에서 두 트랜잭션
     이 같은 enrollment를 읽은 뒤 경합할 수 있고, src/main/java/com/musinsa/domain/course/Course.java:56의 IllegalStateException 또는
     stale delete 계열 예외로 500이 날 수 있습니다. 현재 src/main/java/com/musinsa/api/exception/GlobalExceptionHandler.java:12는 이
     케이스를 처리하지 않습니다.

HTTP 메서드 중에서 DELETE는 멱등성있게 처리를 해야하니, DELETE /api/enrollments/{id} 도 멱등을 보장해야할 것 같아. 타당한가?

---

 1. D는 그대로 전역 IllegalStateException 매핑은 비추천
     IllegalStateException은 다른 버그도 포함할 수 있어서 500을 409로 숨길 수 있습니다.
     방어를 넣고 싶으면 IllegalStateException 대신 도메인 전용 예외 타입(또는 BusinessException)만 핸들링하세요.
  2. EnrollmentRepository.findByIdWithLock()는 락 쿼리로 추가
     @Lock(PESSIMISTIC_WRITE) + @Query("select e from Enrollment e where e.id = :id")(필요하면 join fetch e.course)로 구현하면 됩니다.
  3. 테스트/문서 동기화 필요
     DELETE를 204 No Content + void로 바꾸면 기존 message 응답 기대 테스트와 docs/api/endpoints.md의 200 응답 설명은 같이 수정해야 합
     니다.

Codex 5.3이 피드백한 내용이야. 타당한지 판단해