# 요구사항 분석 및 설계 결정

## 1. 요구사항 분석

### 1.1 명시된 요구사항

| 구분 | 요구사항 | 출처 |
|------|----------|------|
| 기능 | 학생 목록 조회 | 기획팀 메모 |
| 기능 | 강좌 목록 조회 (전체, 학과별) — 정원/현재 인원/시간 정보 포함 | 기획팀 메모 |
| 기능 | 교수 목록 조회 | 기획팀 메모 |
| 기능 | 수강신청 | 기획팀 메모 |
| 기능 | 수강취소 | 기획팀 메모 |
| 기능 | 내 시간표(이번 학기) 조회 | 기획팀 메모 |
| 제약 | 학생당 최대 18학점 | 기획팀 메모 |
| 제약 | 동일 시간대 중복 수강 불가 | 기획팀 메모 |
| 제약 | 정원 초과 시 정확히 1명만 성공 | 기획팀 메모 |
| 기술 | GET /health -> 200 OK | PROBLEM.md |
| 기술 | REST API | PROBLEM.md |
| 데이터 | 학과 10+, 강좌 500+, 학생 10,000+, 교수 100+ | PROBLEM.md |
| 데이터 | 동적 생성, 현실적 데이터, 1분 이내 | PROBLEM.md |

### 1.2 도출된 요구사항 (명시되지 않은 것)

#### 인증/인가
- **결정**: 구현하지 않음
- **근거**: 기획팀 메모에 인증 관련 요구 없음. "화면은 프론트팀에서 따로 작업"이라는 언급으로 보아 API 서버만 요청. 핵심 기능(수강신청, 동시성 제어)에 집중하기 위해 인증은 후순위로 판단. 필요 시 Spring Security + JWT로 확장 가능한 구조 유지.

#### 수강신청 정책
- **결정**: 신청/취소만 지원. 수강 변경(교체)은 취소 후 재신청으로 처리. 재수강 제한 없음. 취소 기한 제한 없음. 취소는 멱등(DELETE 멱등성, RFC 9110).
- **근거**: 기획팀이 "수강신청"과 "수강취소"만 명시. 복잡한 정책(변경, 재수강 제한, 취소 기한)은 명시되지 않았으므로 단순하게 구현. 취소 API는 동시 요청 시 레이스 컨디션으로 인한 500 에러와 enrolled 이중 차감 문제를 방지하기 위해 Enrollment 비관적 락 + 멱등 처리를 적용 (상세: ADR-003). 실제 운영 시에는 수강 변경 기간, 취소 기한 등의 추가 정책이 필요할 수 있으며, 이는 Enrollment 엔티티에 상태(status) 필드를 추가하여 확장 가능.

#### 시간표 슬롯 정의
- **결정**: 요일(월~금) x 교시(1~9교시) 조합. 교시당 50분 수업.
- **근거**: 대학교 표준 시간표 기준. 교시별 시간은 다음과 같다:
  - 1교시: 09:00~09:50
  - 2교시: 10:00~10:50
  - 3교시: 11:00~11:50
  - 4교시: 12:00~12:50
  - 5교시: 13:00~13:50
  - 6교시: 14:00~14:50
  - 7교시: 15:00~15:50
  - 8교시: 16:00~16:50
  - 9교시: 17:00~17:50
- **표현 형식**: `"MON_1,MON_2,WED_1"` — 요일_교시 조합의 콤마 구분 문자열

#### 학점 분포 및 범위
- **결정**: 강좌당 1~3학점. 분포: 1학점(10%), 2학점(30%), 3학점(60%).
- **근거**: 실제 대학교 강좌의 대다수가 3학점이며, 실험/실습 과목이 1~2학점인 경우가 많음. 학점에 따라 교시 수가 결정됨 (1학점=1교시, 2학점=2교시, 3학점=3교시).

#### 동시성 범위
- **결정**: 강좌 단위 + 학생 단위 이중 비관적 락.
  - **강좌 락**: Course 행에 `PESSIMISTIC_WRITE` → 정원 초과 방지 (핵심)
  - **학생 락**: Student 행에 `PESSIMISTIC_WRITE` → 동일 학생의 동시 다중 신청 시 학점 초과/시간 충돌 방지
- **근거**: 기획팀의 핵심 요구 "정원이 1명 남은 강좌에 100명이 동시에 신청해도, 정확히 1명만 성공"을 만족시키기 위해 비관적 락 선택. 낙관적 락은 재시도 로직이 필요하고 실패율이 높아 사용자 경험이 좋지 않음.
- **동일 학생 동시 신청 시나리오**: 학생 A가 강좌1과 강좌2를 동시에 신청하면, Student 행 락으로 순차 처리됨. 첫 번째 신청이 완료된 후 두 번째 신청에서 학점/시간 검증이 정확하게 수행됨.
- **동일 수강신청 동시 취소 시나리오**: Enrollment 행에 비관적 락을 걸어 직렬화. 첫 번째 트랜잭션이 삭제 후 커밋하면, 두 번째는 락 대기 후 행이 없으므로 멱등 리턴 (ADR-003).
- **데드락 방지**: 락 획득 순서를 고정하여 데드락 회피 — 신청: Student → Course, 취소: Enrollment → Course.

#### 동일 강좌 중복 신청
- **결정**: DB 레벨(UNIQUE 제약)과 애플리케이션 레벨(검증 로직) 모두에서 방지
- **근거**: 이중 안전장치. DB 제약은 최종 방어선, 애플리케이션 검증은 의미 있는 에러 메시지 반환용.

#### 페이징
- **결정**: 1차 구현에서는 페이징 없이 전체 목록 반환. 학생 10,000명 목록은 성능 이슈가 있을 수 있으나, 핵심 기능 구현 우선.
- **근거**: 기획팀이 페이징을 명시하지 않음. 핵심 기능 완성 후 필요 시 Spring Data의 Pageable로 쉽게 추가 가능.

## 2. 설계 결정

### 2.1 동시성 제어 전략

- **선택지**:
  1. 낙관적 락 (Optimistic Lock) — @Version 사용. 충돌 시 예외 발생, 클라이언트 재시도 필요.
  2. 비관적 락 (Pessimistic Lock) — SELECT FOR UPDATE. 행 수준 잠금, 순차 처리 보장.
  3. DB 유니크 제약 + 예외 처리 — 정원 관리에는 적용 불가.
- **결정**: 비관적 락 (Pessimistic Lock)
- **근거**: 수강신청은 충돌이 매우 빈번한 시나리오(인기 강좌에 다수 동시 접근). 낙관적 락은 충돌 시 재시도가 필요하여 사용자 경험 저하. 비관적 락은 순차 처리를 보장하므로 정확히 정원만큼만 성공시킬 수 있음. H2 인메모리 DB 환경에서 행 수준 락의 성능 오버헤드는 무시할 수 있는 수준.

**구현 방식:**
```java
// 1. 학생 락 (학점/시간 검증 직렬화)
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT s FROM Student s WHERE s.id = :id")
Optional<Student> findByIdWithLock(@Param("id") Long id);

// 2. 강좌 락 (정원 검증 직렬화)
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT c FROM Course c WHERE c.id = :id")
Optional<Course> findByIdWithLock(@Param("id") Long id);
```

**락 획득 순서:** Student → Course (데드락 방지를 위해 항상 동일 순서로 획득)

**트랜잭션 격리 레벨:** Spring 기본값 (READ_COMMITTED) 사용. 비관적 락과 조합하여 충분한 동시성 제어 달성.

### 2.2 시간표 슬롯 정의

- **결정**: 문자열 저장 (`"MON_1,MON_2,WED_1"`)
- **근거**: 별도 테이블 분리 대비 구현 단순. 시간 충돌 검증은 애플리케이션 레벨에서 문자열 파싱으로 처리. H2 인메모리 환경에서 성능 이슈 없음. 향후 별도 테이블로 마이그레이션 가능.

### 2.3 학점 분포 및 범위

- **결정**: 1~3학점. 학점 수 = 주당 교시 수.
- **근거**: 실제 대학교 기준. 1학점 강좌는 주 1교시, 2학점은 주 2교시, 3학점은 주 3교시. 시간표 슬롯과 일관성 유지.

### 2.4 데이터 생성 전략

- **결정**: `CommandLineRunner` 구현체에서 서버 시작 시 자동 생성
- **근거**: Spring Boot의 표준 초기화 메커니즘. `@PostConstruct` 대비 트랜잭션 관리가 용이.

**생성 순서:** Department → Professor → Course → Student (외래키 의존 순서)

**생성 규모:**
| 항목 | 수량 | 전략 |
|------|------|------|
| 학과 | 10개 | 고정 목록 (컴퓨터공학과, 경영학과 등) |
| 교수 | 100명 | 학과당 10명, 한국어 성+이름 조합 |
| 강좌 | 500개 | 학과당 50개, 교수 배정, schedule 자동 생성 |
| 학생 | 10,000명 | 학과/학년 균등 분배, 학번 자동 생성 |

**데이터 정합성:** 교수의 강의 시간이 겹치지 않도록 생성. 강좌 schedule은 교수별로 비충돌 슬롯 할당.

#### 세부 결정 사항

| 항목 | 결정 | 근거 |
|------|------|------|
| 강좌 정원 범위 | 30~50명 | 실제 대학 강좌의 일반적 정원 범위. `30 + random(21)` |
| 교수 1인당 강의 수 | 약 5개 (50강좌 / 10교수 라운드로빈) | 실제 대학 교수의 학기당 강의 부담(3~6개)과 유사 |
| 교수 시간 충돌 방지 | 교수별 사용 슬롯을 추적하여 중복 할당 방지 | 현실적 데이터 정합성 보장 |
| 연속 교시 선호 | 같은 요일 연속 슬롯을 우선 배정, 불가 시 랜덤 | 실제 대학 시간표에서 3학점 강좌는 연속 교시 배치가 일반적 |
| 초기 수강신청 데이터 | 없음 (빈 상태로 시작) | 평가자가 수강신청/취소를 직접 테스트할 수 있도록 의도적으로 비워둠 |
| 학번 형식 | `2026XXXX` (예: 20260001) | 현재 연도 + 4자리 순번. 1부터 10000까지 순차 부여 |
| 학년 분포 | 1~4학년 균등 분배 (`(i % 4) + 1`) | 학과별로도 균등하게 분포 |
| 이름 생성 | 성(20종) + 이름(40종) 랜덤 조합 | 한국어 실명 패턴. 고정 seed(`Random(42)` 등)로 재현 가능 |
| 강좌명 생성 | 학과별 20개 고정 목록 + 넘버링 확장 | 학과당 50개 필요 → 20개 기본명 + "강좌명 2", "강좌명 3" 식으로 확장 |

### 2.5 엔티티 연관관계

- **결정**: JPA 연관관계(@ManyToOne) 사용
- **근거**: 데이터 무결성 보장(FK 제약), 조회 시 JOIN 편의성, JPA 표준 방식. Enrollment의 경우에도 Student, Course를 @ManyToOne으로 참조하되, 동시성 제어는 Course 엔티티의 비관적 락으로 처리.

### 2.6 에러 응답 설계

- **결정**: 통합 에러 응답 형식 사용
- **형식**:
```json
{
  "error": "CAPACITY_EXCEEDED",
  "message": "강좌 정원이 초과되었습니다."
}
```

## 3. 비즈니스 규칙 정리

| 규칙 | 설명 | 위반 시 HTTP 상태 | 에러 코드 | 메시지 |
|------|------|------------------|----------|--------|
| 정원 제한 | 강좌 정원 초과 불가 | 409 Conflict | CAPACITY_EXCEEDED | 강좌 정원이 초과되었습니다. |
| 학점 상한 | 학생당 최대 18학점 | 400 Bad Request | CREDIT_LIMIT_EXCEEDED | 최대 수강 가능 학점(18학점)을 초과합니다. |
| 시간 충돌 | 동일 시간대 중복 수강 불가 | 409 Conflict | SCHEDULE_CONFLICT | 이미 신청한 강좌와 시간이 겹칩니다. |
| 중복 신청 | 동일 강좌 중복 신청 불가 | 409 Conflict | DUPLICATE_ENROLLMENT | 이미 신청한 강좌입니다. |
| 학생 미존재 | 존재하지 않는 학생 ID | 404 Not Found | STUDENT_NOT_FOUND | 학생을 찾을 수 없습니다. |
| 강좌 미존재 | 존재하지 않는 강좌 ID | 404 Not Found | COURSE_NOT_FOUND | 강좌를 찾을 수 없습니다. |
| 수강신청 미존재 | 존재하지 않는 수강신청 ID | 404 Not Found | ENROLLMENT_NOT_FOUND | 수강신청 내역을 찾을 수 없습니다. |

## 4. 의도적 미구현 사항

검토했으나 핵심 기능 우선 원칙에 따라 의도적으로 미구현한 항목. 향후 확장 가능한 구조를 유지하되, 현재는 YAGNI 원칙 적용.

| 항목 | 미구현 근거 | 확장 방안 |
|------|-----------|----------|
| 선수과목 제한 | 기획팀 요청 없음. 강좌 간 의존관계 도입 시 데이터 모델 복잡도 급증 | Course에 prerequisiteCourseId FK 추가 |
| 학년별 수강 제한 | 기획팀 요청 없음. 학년 필드 존재하므로 검증 로직만 추가하면 됨 | EnrollmentService에 학년 검증 조건 추가 |
| 전공/교양 구분 | 기획팀 요청 없음. 카테고리 분류 시 졸업 요건 관리까지 확장 필요 | Course에 category(MAJOR/GENERAL) 필드 추가 |
| 수강신청 기간 관리 | 기획팀이 기간 제한 미언급. 상시 신청/취소 가능으로 운영 | 시스템 설정 테이블 또는 application.yml로 기간 관리 |
| 최소 수강 학점 | 최대 18학점만 명시. 최소 학점은 학사 정책으로 학교마다 상이 | EnrollmentService에 최소 학점 검증 추가 |
| 성적/이수 관리 | 수강신청 시스템 범위 밖. 별도 시스템으로 분리 권장 | Grade 엔티티 + GradeService 신규 도메인 |
| 대기열(웨이팅) | 정원 초과 시 즉시 실패 반환. 대기열은 UX/인프라 복잡도 증가 | Waitlist 엔티티 + 취소 시 자동 승격 이벤트 |
| 수강 변경(교체) | 취소 후 재신청으로 대체 가능. 이미 수강신청 정책에 기록 | 원자적 교체 API(POST /api/enrollments/swap) |
| 인증/인가 | 기획팀 요청 없음. 핵심 기능 우선 | Spring Security + JWT. 현재 구조에서 Filter 추가로 확장 가능 |
| 페이징 | 기획팀 미언급. 10,000명 전체 반환은 성능 이슈 가능 | Spring Data Pageable 파라미터 추가로 즉시 확장 가능 |

## 5. ERD

상세 ERD는 `prompts/plans/2026-02-08-erd-design.md` 참조.

### 엔티티 관계 요약

```
Department ──┬── 1:N ──→ Student
             ├── 1:N ──→ Professor
             └── 1:N ──→ Course

Professor ───── 1:N ──→ Course

Student ─────── 1:N ──→ Enrollment ←── N:1 ──── Course
```

### 핵심 제약

- `Student.studentNumber`: UNIQUE
- `Department.name`: UNIQUE
- `Enrollment(student_id, course_id)`: UNIQUE (중복 신청 방지)
- `Course.enrolled`: 비관적 락 대상 (동시성 제어)
