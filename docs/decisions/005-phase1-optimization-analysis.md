# ADR-005: Phase 1 최적화 개별 효과 검증 및 인덱스/배치 불필요 결정

## 상태
Accepted

## 맥락

Phase 1에서 적용한 5가지 최적화(HikariCP pool 확대, OSIV OFF, Tomcat 쓰레드 확대, 인덱스 추가, Hibernate batch)의 개별 효과가 불분명했다.
초기 bootRun 기반 측정에서는 각 최적화의 효과가 "없는 것"으로 관측되었으나, `java -jar`로 전환하여 CLI 인자가 정상 적용된 후 각 최적화를 단계별로 격리 측정하여 실제 효과를 검증했다.

**테스트 조건:** instant spike (1s만에 500VU), `java -jar` 실행, MySQL 8.0, 인기 강좌 50개 (정원 합계 2,018명), 학생 10,000명

## 검증 결과

### Step 1: HikariCP pool 10→30 — 지배적 개선

| 지표 | Phase 0 (pool=10) | Step 1 (pool=30) | 변화 |
|------|-------------------|-------------------|------|
| avg | 70.0ms | 26.6ms | **-62.0%** |
| p95 | 128ms | 47ms | **-63.3%** |
| iterations/s | 2,377 | 3,185 | **+34.0%** |

**원인:** 500 VU 동시 요청 환경에서 HikariCP 기본값 pool=10은 극심한 커넥션 대기 발생.
30개로 확대하면 대기 시간이 대폭 줄어들어 전체 응답시간이 62% 감소.
Phase 1의 다른 모든 최적화를 합쳐도 이 단일 변경의 효과를 넘지 못함.

### Step 2: OSIV OFF — 소폭 추가 개선

| 지표 | Step 1 | Step 2 (+OSIV OFF) | 변화 |
|------|--------|---------------------|------|
| avg | 26.6ms | 24.2ms | **-9.0%** |
| p95 | 47ms | 43.5ms | -7.4% |

**원인:** `spring.jpa.open-in-view=false`로 트랜잭션 종료 즉시 커넥션 반환.
OSIV ON(기본값)에서는 뷰 렌더링까지 커넥션을 잡고 있어 풀 활용률이 낮았음.

### Step 3: Tomcat threads 200→500 — 효과 없음 (미세 악화)

| 지표 | Step 2 (threads=200) | Step 3 (threads=500) | 변화 |
|------|----------------------|----------------------|------|
| avg | 24.2ms | 25.6ms | +5.8% |
| burst avg | 42.5ms | 47.6ms | +12.0% |

**원인:** HikariCP pool=30이 실질 병목.
Tomcat 쓰레드를 500으로 늘려도 결국 30개 DB 커넥션을 두고 경쟁하는 쓰레드만 증가.
500개 쓰레드 간 컨텍스트 스위칭 오버헤드가 오히려 burst 구간 성능을 악화시킴.

### Step 4: 인덱스 + batch_size=50 — 효과 없음

| 지표 | Step 2 (최적) | Step 4 (+인덱스+batch) | 변화 |
|------|--------------|------------------------|------|
| avg | 24.2ms | 27.0ms | +11.6% |
| p95 | 43.5ms | 48.5ms | +11.5% |

## 인덱스가 효과 없는 이유 — 상세 분석

### 1. UniqueConstraint가 이미 복합 인덱스를 제공

Phase 0의 Enrollment 엔티티:

```java
@Table(name = "enrollments",
    uniqueConstraints = @UniqueConstraint(columnNames = {"student_id", "course_id"}))
```

MySQL은 `UNIQUE CONSTRAINT`를 생성할 때 자동으로 **복합 인덱스 `(student_id, course_id)`** 를 생성한다.

Phase 1에서 추가한 인덱스:

```java
@Index(name = "idx_enrollment_student_id", columnList = "student_id"),
@Index(name = "idx_enrollment_course_id", columnList = "course_id")
```

이 인덱스들은 이미 존재하는 UK 및 FK 자동 인덱스와 **완전히 중복**된다.

### 2. 복합 인덱스의 선행 컬럼(Leftmost Prefix) 원칙

복합 인덱스 `(student_id, course_id)`의 활용 범위:

| 쿼리 조건 | UK 인덱스 활용 | 이유 |
|-----------|:------------:|------|
| `WHERE student_id = ?` | O | 선행 컬럼 |
| `WHERE student_id = ? AND course_id = ?` | O | 전체 매칭 |
| `WHERE course_id = ?` | **X** | 선행 컬럼이 아님 |

`course_id` 단독 조회는 UK로 커버되지 않지만, 아래 이유로 별도 인덱스가 불필요하다.

### 3. MySQL InnoDB의 Foreign Key 자동 인덱스

JPA의 `@ManyToOne` + `@JoinColumn`은 FK(Foreign Key) 제약조건을 생성한다.
**MySQL InnoDB는 FK 컬럼에 인덱스가 없으면 자동으로 인덱스를 생성한다.**

```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "student_id", nullable = false)  // FK → UK가 이미 커버
private Student student;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "course_id", nullable = false)   // FK → MySQL이 자동 인덱스 생성
private Course course;
```

따라서 Phase 0의 enrollments 테이블에는 명시적 `@Index` 없이도 다음 인덱스가 존재:

| 인덱스 | 생성 방식 | 커버하는 쿼리 |
|--------|----------|-------------|
| PK `(id)` | `@GeneratedValue` | PK 조회 |
| UK `(student_id, course_id)` | `@UniqueConstraint` | student_id 조회, 중복 체크 |
| FK auto-index `(course_id)` | MySQL이 FK에 자동 생성 | course_id 단독 조회 |

### 4. 수강신청 흐름의 실제 쿼리와 인덱스 매핑

```
EnrollmentService.enroll() 흐름:

① SELECT ... FOR UPDATE FROM students WHERE id = ?
   → students PK 인덱스 (비관적 락)

② SELECT ... FOR UPDATE FROM courses WHERE id = ?
   → courses PK 인덱스 (비관적 락)

③ SELECT COUNT(*) FROM enrollments WHERE student_id = ? AND course_id = ?
   → UK (student_id, course_id) — 이미 존재

④ SELECT e.*, c.* FROM enrollments e JOIN courses c WHERE e.student_id = ?
   → UK (student_id, ...) 선행 컬럼 — 이미 존재

⑤ INSERT INTO enrollments (student_id, course_id, enrolled_at)
   → 쓰기 작업 (인덱스가 오히려 INSERT 비용 증가)

⑥ UPDATE courses SET enrolled = enrolled + 1 WHERE id = ?
   → 쓰기 작업
```

**모든 읽기 쿼리(①~④)가 이미 기존 인덱스로 커버된다.**
병목은 ①②의 비관적 락 대기와 ⑤⑥의 쓰기 작업이므로, 인덱스 추가로 개선할 여지가 없다.

### 5. 인덱스 추가가 오히려 악화시키는 이유

- 중복 인덱스는 INSERT 시 추가 인덱스 유지 비용 발생
- enrollments 테이블은 수강신청마다 INSERT가 발생하는 쓰기 위주 테이블
- 인덱스 수 증가 → InnoDB 버퍼 풀에서 인덱스 페이지가 차지하는 비중 증가 → 캐시 효율 저하

## batch_size=50이 효과 없는 이유

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
```

`IDENTITY` 전략은 MySQL의 `AUTO_INCREMENT`를 사용한다.
INSERT 실행 후 생성된 ID를 즉시 반환받아야 JPA 영속성 컨텍스트에서 엔티티를 관리할 수 있다.
이 요구사항 때문에 **Hibernate는 IDENTITY 전략에서 JDBC 배치를 자동 비활성화**한다.

`spring.jpa.properties.hibernate.jdbc.batch_size=50`을 설정해도 실제로는 **한 건씩 INSERT**된다.

> Hibernate 공식 문서: "There is an important difference here between IDENTITY and SEQUENCE: since the value is generated by the INSERT, there's really no way for the ORM to 'batch' these inserts."

JDBC 배치를 사용하려면 `SEQUENCE` 또는 `TABLE` 전략으로 변경해야 하지만, MySQL은 네이티브 시퀀스를 지원하지 않으므로 `TABLE` 전략의 오버헤드를 감수해야 한다.

## 결정

**Phase 1의 최적 구성은 Step 2 (HikariCP pool=30 + OSIV OFF)로 확정한다.**

- **채택:** HikariCP pool=30, OSIV OFF
- **제거:** Tomcat threads 확대, 인덱스 추가, batch_size 설정 (효과 없음 검증 완료)

## 결과

### 최적화 효과 요약

| 최적화 | 효과 | 상태 |
|--------|------|------|
| HikariCP pool=30 | avg -62%, 처리량 +34% | **채택** |
| OSIV OFF | avg -9% 추가 | **채택** |
| Tomcat threads 500 | 효과 없음 (미세 악화) | **제거** |
| 인덱스 추가 | 효과 없음 (중복 인덱스) | **제거** |
| batch_size=50 | 효과 없음 (IDENTITY 전략) | **제거** |

### 교훈

1. **인덱스 추가 전 기존 인덱스를 반드시 확인한다.** UniqueConstraint, FK가 이미 인덱스를 생성하는지 `SHOW INDEX FROM` 또는 MySQL Explain으로 검증.
2. **IDENTITY 전략에서는 JDBC 배치가 불가능하다.** 배치 INSERT가 필요하면 ID 생성 전략 변경을 먼저 검토.
3. **쓰기 위주 워크로드에서 인덱스 추가는 역효과가 될 수 있다.** 읽기 성능 향상보다 쓰기 비용 증가가 클 수 있음.
4. **병목 지점을 정확히 파악한 후 최적화한다.** 이 시스템의 병목은 커넥션 풀 크기 → 락 대기 → 쓰기 순이며, 인덱스는 병목이 아니었음.
